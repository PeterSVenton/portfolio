<h1>Scalable Power BI Architecture with PBIP</h1>
<h2>Context</h2>
<p>In my current work I‚Äôve been helping establish version-controlled, modular Power BI environments.<br>
The goal is to make semantic models scalable, reviewable, and easily shared across development teams without losing the agility that makes Power BI so useful.</p>
<p>This project uses a public dataset to demonstrate that same architectural pattern in an open, reproducible way.<br>
It highlights how PBIP (Power BI Project files), Git, and a consistent DAX naming convention together create a professional-grade modeling environment.</p>
<div><span><span>Purpose</span></span></div><div><p>This project is both a demonstration and a living pattern.<br>
It shows how to treat a Power BI model like code: structured, versioned, and composable.</p></div>
<hr>
<h2>The Goal</h2>
<h3>Functional Goals</h3>
<ol>
<li>Show how <code>.pbip</code> project structures enable source-controlled Power BI models.</li>
<li>Demonstrate a consistent naming framework for measures that clarifies intent and dependency.</li>
<li>Enable semantic model reusability across workspaces and repositories.</li>
<li>Illustrate how this approach integrates into team-based analytics workflows.</li>
</ol>
<h3>Design Goals</h3>
<ul>
<li>Keep everything versionable instead of relying on binary <code>.pbix</code> files.</li>
<li>Maintain human-readable structure for diffs and reviews.</li>
<li>Provide clear separation between dataset, report, and connections.</li>
<li>Document conventions so new developers can onboard quickly.</li>
</ul>
<hr>
<h2>PBIP Overview</h2>
<p>Power BI Project (<code>.pbip</code>) files are text-based representations of Power BI Desktop projects.<br>
They break down a <code>.pbix</code> into smaller parts that can be tracked in Git.</p>
<p>A typical PBIP structure looks like this:</p>
<pre><code>üìÅ SalesModel.pbip
 ‚î£ üìÇ Dataset
 ‚îÉ ‚î£ model.bim
 ‚îÉ ‚îó connections.json
 ‚î£ üìÇ Report
 ‚îÉ ‚î£ report.json
 ‚îÉ ‚îó visuals/
 ‚î£ project.json
</code></pre>
<p>This separation allows independent updates to dataset or report logic.<br>
Changes to <code>model.bim</code> (which defines measures, relationships, and metadata) can be reviewed like any other code.<br>
Teams can collaborate without overwriting the entire file.</p>
<div><span><span>PBIP in Practice</span></span></div><div><p>In my current role PBIP has become the foundation for peer-reviewed Power BI development.<br>
Teams commit model changes as pull requests so DAX logic can be reviewed just like SQL or Python.</p></div>
<hr>
<h2>Version Control Integration</h2>
<p>The <code>.pbip</code> folder works naturally with Git.<br>
Because files like <code>model.bim</code> are JSON, Git can detect changes to measures, relationships, and KPIs.</p>
<p>Typical workflow:</p>
<ol>
<li>Initialize a repo for the PBIP folder.</li>
<li>Create feature branches for measure or dataset updates.</li>
<li>Commit and push changes using Power BI Desktop or Tabular Editor.</li>
<li>Use pull requests for review and merge into main.</li>
<li>Deploy automatically through Fabric or the Power BI REST APIs.</li>
</ol>
<p>This turns a Power BI model into a managed, reviewable code asset.</p>
<hr>
<h2>Naming Conventions for Measures</h2>
<p>As models grow, naming becomes just as important as logic.<br>
I use a light Hungarian notation style to make the intent of each measure obvious at a glance.<br>
The idea is simple: the prefix tells you how the measure behaves before you even open it.</p>
<p>Hungarian notation is a naming convention that uses prefixes or symbols to describe the purpose or behavior of a variable.<br>
In Power BI I adapt this approach for DAX measures so each measure name encodes how it behaves in the semantic model.<br>
For example, <code>_</code> means a raw aggregation, <code>?</code> means it changes filter context, and <code>$</code> means it derives its value from other measures.<br>
This makes models self-documenting and easier to maintain at scale.</p>
<p>| Symbol | Meaning | Example | Description |
|---------|----------|----------|--------------|
| <code>_</code> | Base measure using aggregation only | <code>_sumSales</code> | Simple aggregation (no CALCULATE) |
| <code>?</code> | Measure altering filter context | <code>?sumSales(Year=2025)</code> | Uses CALCULATE or context manipulation |
| <code>^</code> | Measure that uses an iterator function | <code>^sumxNetInvoiceValue(dim_date)</code> | Uses an iterator function to compute a measurre over a table |
| <code>%</code> | Ratio or rate | <code>%Margin</code> | Value between 0 and 1 |
| <code>$</code> | Derived measure using other measures | <code>$Margin</code> | Combines other measures (e.g. <code>DIVIDE([_sumProfit], [_sumSales])</code>) |
| <code>></code> | Selection-driven measure | <code>>SelectedYear</code> | Uses SELECTEDVALUE |
| <code>*</code> | Independent measure | <code>*WeekToday</code> | No table dependencies (e.g. <code>WEEKNUM(TODAY())</code>) |
| <code>@</code> | Local-only measure | <code>@DebugValue</code> | Exists only in PBIP, not the parent model |
| <code>#</code> | Resolver measure | <code>#CurrentMetric</code> | Returns the correct measure via SWITCH logic |
| <code>+</code> | Formatting or visual measure | <code>+BgColor</code> | Used for conditional formatting |</p>
<p>You can <strong>chain prefixes</strong> together when a measure has multiple characteristics.<br>
For example:</p>
<pre><code class="language-DAX">@$%Margin = DIVIDE([_sumProfit], [_sumSales])
</code></pre>
<p>This means the measure only exists in the current model (<code>@</code>), is derived from other measures (<code>$</code>), and returns a percentage (<code>%</code>).<br>
The order of prefixes should always be:</p>
<pre><code>@, #, ?, $, %
</code></pre>
<p>All other prefixes (<code>_</code>, <code>></code>, <code>*</code>, <code>+</code>) must be used on their own.<br>
Chaining <code>></code> is only valid when used with a resolver (<code>#</code>) because it depends on selection logic.</p>
<div><span><span>Result</span></span></div><div><p>Every measure communicates its intent and context directly in its name.<br>
No need to open the DAX editor just to understand what it does.</p></div>
<hr>
<h2>Implementation Example</h2>
<p>To demonstrate, I built a model using the <strong>Open Government UK Trade dataset</strong>.<br>
It tracks imports, exports, and trade balances over time, structured as follows:</p>
<pre><code>üìÅ TradeAnalytics.pbip
 ‚î£ üìÇ Dataset
 ‚îÉ ‚î£ model.bim
 ‚îÉ ‚îó connections.json
 ‚î£ üìÇ Report
 ‚îÉ ‚î£ Overview.pbir
 ‚îÉ ‚îó visuals/
 ‚î£ project.json
</code></pre>
<p>Example DAX definitions:</p>
<pre><code class="language-DAX">_sumExports = SUM(Trade[Exports])
_sumImports = SUM(Trade[Imports])
$TradeBalance¬£ = [_sumExports] - [_sumImports]
%ExportShare = DIVIDE([_sumExports], [_sumExports] + [_sumImports])
</code></pre>
<p>Once published, the model shows both the calculations and the logic behind them, all versioned and reviewable.</p>
<hr>
<h2>CI/CD Setup</h2>
<p>In my current position this architecture fits into a full Power BI deployment pipeline.<br>
Each semantic model has its own repository, and every environment (Dev, Test, Prod) is linked to a workspace.<br>
PBIP folders deploy through Fabric Deployment Pipelines or Azure DevOps YAML tasks.<br>
Validation scripts run during build to check naming and metadata consistency before publish.</p>
<p>To keep everything compliant, I use a YAML setup that runs a custom validation script during deployment.<br>
It scans all measures in the dataset to confirm they follow the approved prefix order and naming format before allowing the build to proceed.<br>
This helps enforce consistency across projects and stops non-standard naming from slipping through review.</p>
<div><span><span>Governance by Design</span></span></div><div><p>By keeping naming, validation, and metadata rules in the repository itself, the model enforces governance automatically.</p></div>
<hr>
<h2>Results</h2>
<div><div><div>1</div><div>Semantic Model</div><div>Version-controlled via PBIP</div></div><div><div>50+</div><div>Measures</div><div>Structured using naming conventions</div></div><div><div>100%</div><div>Reviewable Changes</div><div>Tracked in Git as code</div></div></div>
<hr>
<h2>Lessons Learned</h2>
<ul>
<li>PBIP makes Power BI a developer-friendly modeling platform.</li>
<li>Version control brings accountability and transparency.</li>
<li>Hungarian-style naming adds clarity to complex DAX logic.</li>
<li>Folder structures make CI/CD predictable and maintainable.</li>
<li>Treating BI models like code keeps them scalable and auditable.</li>
</ul>
<hr>
<h2>Next Steps</h2>
<ul>
<li>Add automated validation checks for naming in CI builds.</li>
<li>Extend conventions to calculated columns and hierarchies.</li>
<li>Link PBIP repos with Fabric Semantic Models for hybrid governance.</li>
<li>Explore YAML-driven deployment metadata for publishing.</li>
</ul>
<hr>
<h2>Conclusion</h2>
<p>Applying code-based discipline to Power BI through PBIP, version control, and clear naming turns semantic models into structured data products rather than opaque files.<br>
The result is a reliable architecture where teams can collaborate, review, and evolve models confidently.</p>
<blockquote>
<p><strong>Model with intent. Govern with structure. Scale with trust.</strong></p>
</blockquote>