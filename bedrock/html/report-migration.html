<h1>Paginated Report Migration</h1>
<div><span><span>info</span></span></div><div><p><strong>TL;DR:</strong> Rebuilt 100+ regulated BOXI reports in Power BI Paginated using shared datasets, parameterised templates, and a Finance signed validation process. Change requests moved from weeks to days and outputs are audit ready.</p></div>
<h2>Context</h2>
<p>The company used BusinessObjects (BOXI) for static PDFs and Power BI for dashboards. BOXI scheduling worked, but metric logic was inconsistent across reports and hard to audit.<br>
Leadership asked to consolidate on Power BI. I took ownership of the paginated layer, reverse engineered BOXI universes, designed reusable SQL datasets, and matched figures exactly.</p>
<div><div><div>100+</div><div>Reports rebuilt</div><div>over 1 year</div></div><div><div>5</div><div>Critical DW issues fixed</div><div>impacting P&#x26;L</div></div><div><div>6x</div><div>Faster changes</div><div>weeks to days</div></div></div>
<h2>Goals</h2>
<ol>
<li>Deliver the same PDF and Excel outputs from Power BI Paginated.</li>
<li>Replace fragmented BOXI logic with a governed, reusable SQL layer.</li>
<li>Standardise templates and parameters for quicker change control.</li>
<li>Validate totals against BOXI and secure Finance sign off.</li>
</ol>
<h2>Challenges</h2>
<ul>
<li>Duplicated and conflicting metric definitions in BOXI.</li>
<li>Limited visibility into universe SQL and joins.</li>
<li>Customer facing schedules required a zero defect cutover.</li>
<li>Sparse documentation for some legacy variables.</li>
</ul>
<h2>Approach</h2>
<h3>1. Audit and prioritisation</h3>
<p>I requested a monthly export of all BOXI schedules and recipients. From that I built two working indexes:</p>
<ul>
<li>
<p><strong>Report index</strong> ranked by number of schedules and customer exposure.<br>
This identified the highest value reports to migrate first.</p>
</li>
<li>
<p><strong>Recipient index</strong> grouped by user and department.<br>
This showed dependency clusters and consolidation opportunities.</p>
</li>
</ul>
<p>These indexes became the plan of record for migration and communication.</p>
<h3>2. Rationalising logic</h3>
<p>Each BOXI report was reviewed and categorised:</p>
<ul>
<li><strong>Rebuild</strong> when logic was correct but needed standardisation.</li>
<li><strong>Fix</strong> when logic or joins were wrong.</li>
<li><strong>Retire</strong> when the rule was no longer valid.</li>
</ul>
<p>I created a small canonical SQL layer using views and CTEs for shared business metrics. This replaced BOXI variables and removed one off definitions. I also moved away from hard coded variables such as <code>warehouse_1</code>, <code>warehouse_2</code> by using dynamic groups in Report Builder, so new values appear automatically.</p>
<h3>3. Clean SQL pattern</h3>
<p>Aggregate the fact first by keys and date, then join dimensions for descriptions. This keeps queries readable and index friendly.</p>
<pre><code class="language-sql">WITH fact_summary AS (
  SELECT
    s.dim_customer_key,
    s.dim_salesperson_key,
    d.year,
    d.month,
    SUM(s.cases_sold) AS cases_sold
  FROM fact_sales s
  JOIN dim_date d
    ON s.dim_order_date_key = d.dim_date_key
  WHERE d.year = @year
  GROUP BY
    s.dim_customer_key,
    s.dim_salesperson_key,
    d.year,
    d.month
)
SELECT
  c.customer_number,
  c.customer_name,
  u.full_name AS salesperson_name,
  f.year,
  f.month,
  f.cases_sold
FROM fact_summary f
JOIN dim_customer c
  ON f.dim_customer_key = c.dim_customer_key
JOIN dim_user u
  ON f.dim_salesperson_key = u.dim_user_key;
</code></pre>
<p>Why this works well:</p>
<ul>
<li>Short, predictable <code>GROUP BY</code> on keys and date.</li>
<li>Adding a new descriptive field is just another column from a dimension.</li>
<li>Execution plans benefit from key indexes on the fact.</li>
</ul>
<h3>4. Parameterised reports</h3>
<p>Legacy reports were often fixed to a period such as this month versus last month.<br>
Each paginated report was rebuilt with parameters so a user can pick any period. SQL calculates the comparison period and headers render with real month and year, for example <code>Sales 2024 Jan</code> and <code>Sales 2023 Dec</code>.<br>
This reduced duplicate schedules and improved self service.</p>
<h3>5. Validation with Python</h3>
<p>I wrote a small Pandas utility to compare BOXI and PBI outputs by shape, columns, and totals. Finance signed off each report once the diff was empty.</p>
<pre><code class="language-python">from mylibrary import check_reports

pbi = pd.read_excel("pbi_report.xlsx", index=["customer_number","year","month"])
boxi = pd.read_excel("boxi_report.xlsx", index=["customer_number","year","month"])

result = check_reports(pbi, boxi)
result.summary()  # shows shape, column, and total differences
</code></pre>
<h3>6. Dynamic scheduling</h3>
<p>BOXI schedules were static and hard to maintain. In Power BI I introduced dynamic per recipient schedules.</p>
<ul>
<li>A small Users semantic model refreshed daily with <code>user_id</code>, name, and email.</li>
<li>Each row drove a parameterised run that filtered to that personâ€™s data and emailed the result.</li>
<li>New staff appeared automatically once added in the ERP.</li>
<li>Managers received fixed schedules where a dynamic approach was not suitable.</li>
</ul>
<h2>Results</h2>
<ul>
<li>100+ paginated reports rebuilt on shared datasets.</li>
<li>Change requests completed in days instead of weeks.</li>
<li>Critical data warehouse issues identified and fixed during rebuild.</li>
<li>Dynamic schedules removed manual maintenance and improved auditability.</li>
<li>Finance validated that totals and outputs match the prior estate.</li>
</ul>
<h2>Lessons learned</h2>
<ul>
<li>A thin canonical SQL layer removes drift and speeds up changes.</li>
<li>Aggregate first, then join dimensions keeps queries simple and fast.</li>
<li>Parameterised templates reduce schedule sprawl and improve usability.</li>
<li>Lightweight validation scripts build trust and shorten approvals.</li>
</ul>
<h2>Conclusion</h2>
<p>The migration replaced a fragile BOXI estate with a governed, reusable reporting layer in Power BI.<br>
By standardising the logic, validating results, and automating delivery, reporting moved from reactive maintenance to a predictable and auditable process that the business can trust.</p>