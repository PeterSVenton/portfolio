# Clean Models and Reusable Logic

## Whats the Difference between Good BI and Great BI?

Have you ever had to update a report you didn't build? Perhaps you need to add a new basic measure. You download the report from the service expecting a quick addition, but then it hits you.

The model is a mess. No clear structure. Dozens of measures, many of them duplicating the same logic in slightly different ways. No naming conventions. No documentation. Just chaos.

The report technically works. But it's not scalable. It's not clean. And it's definitely not easy to maintain.

This is something Iâ€™ve seen far too often. While the dashboards may look good on the surface, they usually suffer from the same core issues:
- They answer the question, but only that question
- Logic is duplicated across measures leading to inconsistincies in the report
- Making a minor change means rewriting logic in multiple places
- Performance suffers as complexity grows

With all of these issues it becomes clear, **the semantic model is an afterthought, not the foundation.**

## Empowering Users to Answer their own Questions
While this isn't a part of the model I still feel obligated to include it as a bullet point due to such a simple fix. Far too often have I found a dashboard with multiple tabs but every tab follows the same layout, for example a supply chain dashboard showing free stock available on tab 1 and stock on order on tab 2, same layout and visuals on both tabs.

Free Stock may be a measure called _sumFreeStock whereas stock on order may be a measure called _stockOnOrder, a simple way to let the user choose which measure they want to have be used in the current context is to use Field Parameters, a relatively new feature in PowerBI.

## Building Beautiful Models
In order to build a scalable solution the model structure, tables, and design choices must be the first thing you think of. There are some clear goals to meet:
1. Does my model architecture make it easy for other analysts to build reports off of this model?
2. Are all the tables I have in the model necessary, are all the fields needed?
3. Is this measure I just created resuable in other reports that may drive off this model?
4. Do my measures follow naming conventions so other analysts can infer the calculation without having to inspect the DAX?

### Which fields to bring into the model
Often the source data PowerBI drives off has more information available than would ever be used, A common scenario is a SQL database with a transactions table with 200 fields. Perhaps these 200 fields are used by the ERP system, a common scenario is a field storing the value of the transaction in the currency of the transaction and a field storing the value of the transaction in local currency. Often the business only needs to know their turnover in local currency, therefore a set of foundational fields need to be established. If a field is needed in the future which is not available in the model you can always go in and update the query.

Additionally, sometimes fields should not be in a specific model. Lets say you've decided to split your semantic models by department, the Sales department has their own sales semantic model which drives all of their PBI reports, but Sales is never allowed to know the cost of a product (the supplier price). The sales model should not include the `supplier_price` field, if someone else is using your model and supplier_price is an available field they may accidentally show the field.


### Avoiding Measure Hell
When I first started using PowerBI, I found myself repeating a lot of the logic I was writing. i.e If I had a measure for Sales, Net Margin and Cost of Goods Sold, now if I want to have the same measures but only show the values for Year to Date I'd have to create 3 new measures wrapping the original measures in a CALCULATE().

Instead of doing this you should be making use of Calculation Groups, if you come from a programming background you can think of these to be the most similar thing in powerBI to a function, except the function takes 1 argument and the argument is a measure. Take the previous example instead of creating 3 new measures you'd create a calculation group called Time Intelligence and a calculation item could be Year to Date, with the definition being:

```
Year to Date =
VAR _CurrentYear = YEAR(TODAY())

RETURN
CALCULATE(SELECTEDMEASURE(), dim_date[year] = _CurrentYear)
```

If you have a visual with a measure you can now add your calculation group to the filters pane on the visual, then select Year To Date and now the measure will be evaluated in the new filter context.

There are some cases where this does not work, which I'd love the PowerBI team to add functionality for. i.e if you have the measure exist as a field in a table or matrix visual its only possible to add the filter onto the entire table or matrix visual modifying the filter context of all measures in the table. What would be great if we could apply the filter to the specific column, in such cases you will still need to create a separate measure, however calculation groups clean up models significantly.


### Measure Naming Conventions
If you come from a programming background you'll know every language/framework is extremely opinionated, especially on naming conventions. Coming to PowerBI you might be shocked Microsoft doesn't suggest or at least give an opinion on how to name our measures. I've found the following to work best:

| Prefix | Convention |  Example | Definition | Usage Description |
| --- | --- | --- | --- | --- |
| _ | _aggField | _sumNetInvoiceValue | SUM(fact_sales[net_invoice_value])| Basic measure aggregations, the DAX definition should never modify the filter context / not use CALCULATE
| > | >Field | >customerName | SELECTEDVALUE(dim_customer[customer_name]) | Only used for selected values, in case you want to show the selected value on a card visual
| $ | $aggMeasure | $sumNetMargin | [sumNetInvoiceInvoiceValue] - [sumCostOfGoodsSold] | Indicates the measure is **solely** dependent on other measures
| % | %aggMeasure | %sumNetMargin | DIVIDE([sumNetMargin], [sumNetInvoiceValue]) | The value being returned is a percentage
| ! | !aggMeasure(Table) | !sumNetMargin(dim_customer) | CALCULATE([sumNetMargin], REMOVEFILTERS(dim_customer)) | Modifies the filter context by removing filters specified by the field in the brackets

